#' Load raw inventory data and make them ready for CLCC calculation
#'
#' This function loads raw inventory data as xlsx files generated by the LCA SimaPro
#' software. The function loads all the inventories in a given folder: the file name becomes
#' the name of the object to be evaluated. The function also converts raw data to measurement
#' units compatible with those of reference prices.
#' This function can optionally load also critical weights from an Excel file. Such weights are project-specific.
#' Some materials are considered critical by the European Commission of the International Energy Agency (IEA) but are not considered as individual flows by
#' SimaPro. For example the SimaPro flow "Coal, hard" contains "coking coal" which is critical. The weights are therefore needed to
#' compute the Critical-CLCC indicators.
#'
#' @param data_path A character string. Path to the folder in which raw xlsx files are stored.
#'     File names will be used as object names on which computing the CLCC indicator.
#' @param use_weights A logical value. If set to `TRUE`, the function uses the critical weights
#' @param weights_path A character vector. Path to the file containing the critical weights for each commodity and phase.
#' @return A tidy dataset with inventory data organized by object
inventory_load_fn <- function(
    data_path,
    use_weights = FALSE,
    weights_path = NULL
    ){

comm <- file_path <- inventory_raw <- data <- object <- no <- um <-
  um_to <- quantity <- comp <- no_comm <- phase <- NULL # avoids notes (dplyr and NSE)

file_list <- list.files(path = data_path,
                            full.names = TRUE,
                            recursive = TRUE,
                            pattern = "*.xlsx") # creates a vector with variable names


inventory_raw <- tidyr::tibble(file_path = file_list) # creates a tibble


# identifying the number of rows to skip in each excel file

inventory_raw$skip <- purrr::map_dbl(inventory_raw$file_path, start_data_finder_fn)

# loading inventory data
inventory_raw <- inventory_raw |>
  dplyr::rowwise() |>
  dplyr::mutate(data = purrr::map(file_path, readxl::read_excel, skip = skip)) |>
  dplyr::ungroup()

inventory_raw <- within(inventory_raw, {
  object <- stringr::str_remove(file_path, paste0(data_path, "/"))
  object <- stringr::str_remove(object, ".xlsx")
  file_path <- NULL
  skip <- NULL
})

# renaming the first 5 variables of each inventory

inventory_raw <- inventory_raw |>
  dplyr::mutate(data = purrr::map(data,
                                  function(x){
                                    x |>
                                    dplyr::rename(no = 1, comm = 2, comp = 3,
                                                  um = 4, total = 5) |>
                                    #dplyr::rename_all(tolower) |>
                                    dplyr::mutate(dplyr::across(!c(comm, comp, um), function(x) as.numeric(x)))
                                  }))

# tidying the dataset (grouping needed because of different number of phases across objects)

inventory_tidy <- inventory_raw |>
  dplyr::mutate(data = purrr::map(data,
                                  function(x){
                                    tidyr::pivot_longer(x, !c(no:um),
                                    names_to = "phase", values_to = "quantity")
                                  })) |>
  tidyr::unnest(data)

# loading data on measurement units

meas_units <- subset(clccr::clcc_prices_ref,
                     select = c(comm, no_comm, um))

meas_units <- within(meas_units, {
  um_to <- um
  um <- NULL
})

# filtering data (raw materials only, belonging to the list of materials for which prices are available)

# commodities to be considered ####
comm_names <- unique(clccr::clcc_prices_ref$comm)

inventory_tidy <- subset(inventory_tidy,
                         comp %in% c("Prima", "Raw") & comm %in% comm_names)

# converting measurement units

inventory_tidy <- merge(inventory_tidy, meas_units, all.x = TRUE)

inventory_tidy$um <- ifelse(inventory_tidy$um == paste0("\u00b5", "g"), "ug", # \u00b5" unicode character for mu
                                inventory_tidy$um) # micrograms are expressed wit "ug" in the udunits2 package

# removing rows referring to land use changes and to renewable energy (measured in MJ)

inventory_tidy <- inventory_tidy[!inventory_tidy$um %in% c("m2a", "m2", "m3y", "MJ"), ]

inventories <- # all variables in lower case
  inventory_tidy |>
  dplyr::mutate(dplyr::across(
    dplyr::where(is.character), tolower))

# Loading critical weights (is requested)

if (use_weights){

  if (is.null(weights_path)) {

    stop("If 'use_weights' is TRUE, 'weights_path' cannot be NULL, please specify a valid path to the weight table")

  } else {

    critical_weights <-
      critical_weights_load_fn(weights_path = weights_path) # loads the critical weights


    if (length(intersect(unique(critical_weights$object), unique(inventories$object))) !=
        length(unique(critical_weights$object)))
      stop("Not all the objects in the critical weights file are present in the inventories. Please check the files.")

    if (length(intersect(unique(critical_weights[critical_weights$object %in% unique(inventories$object), ]$phase), unique(inventories$phase))) !=
        length(unique(critical_weights$phase)))
      stop("Not all the phases in the critical weights file are present in the inventories. Please check the files.")

  # Manipulating critical weights

    # Share of 'sand' which is used to make silicon metal (critical)

    sand_to_silicon <-
      inventories |>
      dplyr::filter(.data[["comm"]] == "sand") |>
      dplyr::left_join(critical_weights) |>
      dplyr::mutate(weight = ifelse(
        is.na(.data[["weight"]]),
        1,
        .data[["weight"]]
      ),
      comm = "silicon",
      no_comm = 1888
      )

    critical_weights <-
      critical_weights |>
      dplyr::mutate(
        weight = ifelse(
          .data[["comm"]] == "sand", # sand "real" weight once sand shares used in silicon production are subtracted
          1 - .data[["weight"]],
          .data[["weight"]]
        )
      )

    inventories <-
      inventories |>
      dplyr::left_join(critical_weights) |>
      dplyr::bind_rows(sand_to_silicon) # adding silicon from sand


    inventories$weight <- ifelse(is.na(inventories$weight), 1, inventories$weight) # if weight is NA, set it to 1


}


} else {

  inventories$weight <- 1 # if not using weights, set weight to 1

}


  return(inventories)

}


