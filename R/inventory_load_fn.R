#' Load raw inventory data and make them ready for CLCC calculation
#'
#' This function loads raw inventory data as xlsx files generated by the LCA SimaPro
#' software. The function loads all the inventories in a given folder: the file name becomes
#' the name of the object to be evaluated. The function also converts raw data to measurement
#' units compatible with those of reference prices.
#'
#' @param data_path A character vector. Path to the folder in which raw xlsx files are stored.
#' File names will be used as object names on which computing the CLCC indicator.
#' @return A tidy dataset with inventory data organized by object
#' @export
inventory_load_fn <- function(data_path){

db_comm_master <- db_comm_master

comm <- file_path <- inventory_raw <- data <- object <- no <- um <-
  um_to <- quantity <- comp <- no_comm <- NULL # avoids notes (dplyr and NSE)

file_list <- list.files(path = data_path,
                            full.names = TRUE,
                            recursive = TRUE,
                            pattern = "*.xlsx") # creates a vector with variable names

inventory_raw <- tidyr::tibble(file_path = file_list) # creates a tibble

# identifying the number of rows to skip in each excel file

inventory_raw$skip <- purrr::map_dbl(inventory_raw$file_path, start_data_finder_fn)

# loading inventory data
inventory_raw <- inventory_raw %>%
  dplyr::rowwise() %>%
  dplyr::mutate(data = purrr::map(file_path, readxl::read_excel, skip = skip)) %>%
  dplyr::ungroup()

inventory_raw <- within(inventory_raw, {
  object <- stringr::str_remove(file_path, paste0(here::here(data_path), "/"))
  object <- stringr::str_remove(object, ".xlsx")
  file_path <- NULL
  skip <- NULL
})

# renaming the first 5 variables of each inventory

inventory_raw <- inventory_raw %>%
  tidyr::unnest(data) %>%
  as.data.frame()

names(inventory_raw[, 1:5]) <- c("no", "comm", "comp", "um", "total")

names(inventory_raw) <- tolower(names(inventory_raw))

# tidying the dataset (grouping needed because of different number of phases across objects)

inventory_raw_list <- dplyr::group_split(inventory_raw, object)

inventory_raw_list <- purrr::map(inventory_raw_list, function(x){
  tidyr::pivot_longer(x, !c(no:um, object),
                      names_to = "phase", values_to = "quantity")
})

inventory_tidy <- dplyr::bind_rows(inventory_raw_list)

# loading data on measurement units

meas_units <- subset(db_comm_master,
                     select = c(comm, no_comm, um))

meas_units <- within(meas_units, {
  um_to <- um
  um <- NULL
})

# filtering data (raw materials only, belonging to the list of materials for which prices are avilable)

# commodities to be considered ####
comm_names <- unique(db_comm_master$comm)

inventory_tidy <- subset(inventory_tidy,
                         comp %in% c("Prima", "Raw") & comm %in% comm_names)

# converting measurement units

inventory_tidy <- merge(inventory_tidy, meas_units, all.x = TRUE)

inventory_tidy$um <- ifelse(inventory_tidy$um == paste0("\u00b5", "g"), "ug", # \u00b5" unicode character for mu
                                inventory_tidy$um) # micrograms are expressed wit "ug" in the udunits2 package

inventory_tidy <- inventory_tidy %>%
  dplyr::rowwise() %>%
  dplyr::mutate(quantity = udunits2::ud.convert(quantity, um, um_to)) %>%
  dplyr::ungroup()

tidyr::as_tibble(inventory_tidy[, -which(names(inventory_tidy) %in% c("no", "comp", "um", "um_to"))])

}
