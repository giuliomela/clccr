#' Load raw inventory data and make them ready for CLCC calculation
#'
#' This function loads raw inventory data as xlsx files generated by the LCA SimaPro
#' software. The function loads all the inventories in a given folder: the file name becomes
#' the name of the object to be evaluated. The function also converts raw data to measurement
#' units compatible with those of reference prices.
#' This function can optionally load also critical weights from an Excel file. Such weights are project-specific.
#' Some materials are considered critical by the European Commission of the International Energy Agency (IEA) but are not considered as individual flows by
#' SimaPro. For example the SimaPro flow "Coal, hard" contains "coking coal" which is critical. The weights are therefore needed to
#' compute the Critical-CLCC indicators.
#'
#' @param data_path A character string. Path to the folder in which raw xlsx files are stored.
#'     File names will be used as object names on which computing the CLCC indicator.
#' @param use_weights A logical value. If set to `TRUE`, the function uses the critical weights
#' @param weights_path A character vector. Path to the file containing the critical weights for each commodity and phase.
#' @return A tidy dataset with inventory data organized by object
inventory_load_fn <- function(
    data_path,
    use_weights = FALSE,
    weights_path
    ){

comm <- file_path <- inventory_raw <- data <- object <- no <- um <-
  um_to <- quantity <- comp <- no_comm <- phase <- NULL # avoids notes (dplyr and NSE)

file_list <- list.files(path = data_path,
                            full.names = TRUE,
                            recursive = TRUE,
                            pattern = "*.xlsx") # creates a vector with variable names


inventory_raw <- tidyr::tibble(file_path = file_list) # creates a tibble

# identifying the number of rows to skip in each excel file

inventory_raw$skip <- purrr::map_dbl(inventory_raw$file_path, start_data_finder_fn)

# loading inventory data
inventory_raw <- inventory_raw |>
  dplyr::rowwise() |>
  dplyr::mutate(data = purrr::map(file_path, readxl::read_excel, skip = skip)) |>
  dplyr::ungroup()

inventory_raw <- within(inventory_raw, {
  object <- stringr::str_remove(file_path, paste0(data_path, "/"))
  object <- stringr::str_remove(object, ".xlsx")
  file_path <- NULL
  skip <- NULL
})

# renaming the first 5 variables of each inventory

inventory_raw <- inventory_raw |>
  dplyr::mutate(data = purrr::map(data,
                                  function(x){
                                    x |>
                                    dplyr::rename(no = 1, comm = 2, comp = 3,
                                                  um = 4, total = 5) |>
                                    #dplyr::rename_all(tolower) |>
                                    dplyr::mutate(dplyr::across(!c(comm, comp, um), function(x) as.numeric(x)))
                                  }))

# tidying the dataset (grouping needed because of different number of phases across objects)

inventory_tidy <- inventory_raw |>
  dplyr::mutate(data = purrr::map(data,
                                  function(x){
                                    tidyr::pivot_longer(x, !c(no:um),
                                    names_to = "phase", values_to = "quantity")
                                  })) |>
  tidyr::unnest(data)

# loading data on measurement units

meas_units <- subset(clccr::clcc_prices_ref,
                     select = c(comm, no_comm, um))

meas_units <- within(meas_units, {
  um_to <- um
  um <- NULL
})

# filtering data (raw materials only, belonging to the list of materials for which prices are available)

# commodities to be considered ####
comm_names <- unique(clccr::clcc_prices_ref$comm)

inventory_tidy <- subset(inventory_tidy,
                         comp %in% c("Prima", "Raw") & comm %in% comm_names)

# converting measurement units

inventory_tidy <- merge(inventory_tidy, meas_units, all.x = TRUE)

inventory_tidy$um <- ifelse(inventory_tidy$um == paste0("\u00b5", "g"), "ug", # \u00b5" unicode character for mu
                                inventory_tidy$um) # micrograms are expressed wit "ug" in the udunits2 package

inventory_tidy$no <- NULL # removing the no variable which is not needed

# removing rows referring to land use changes and to renewable energy (measured in MJ)

inventory_tidy <- inventory_tidy[!inventory_tidy$um %in% c("m2a", "m2", "m3y", "MJ"), ]

inventories <- # all variables in lower case
  inventory_tidy |>
  dplyr::mutate(dplyr::across(
    dplyr::where(is.character), tolower))

# Loading critical weights (is requested)

if (use_weights){

  if (is.null(weights_path)) {

    stop("If 'use_weights' is TRUE, 'weights_path' cannot be NULL, please specify a valid path to the weight table")

  } else {

    critical_weights <- # it is a list
      critical_weights_load_fn(weights_path = weights_path) # loads the critical weights

    # checking if the coke and silicon tibbles have the same objects and phases

    if (!identical(unique(critical_weights$coke$object), unique(critical_weights$silicon$object)))
        warning("The objects in the coke and the silicon weight tibbles are not the same, please check")

    if (!identical(unique(critical_weights$coke$phase), unique(critical_weights$silicon$phase)))
      warning("The phases in the coke and the silicon weight tibbles are not the same, please check")

    # checking if the inventories and the weights tibbles have the same objects/phases

    purrr::walk(
      c("coke", "silicon"),
      \(x){

        if (length(intersect(unique(critical_weights[[x]][["object"]]), unique(inventories$object))) !=
            length(unique(critical_weights[[x]][["object"]])))
          warning(paste0(
            "Not all the objects in the ", x,  " critical weights file are present in the inventories. Please check the files if it is ok.")
          )

        if (length(intersect(unique(critical_weights[[x]][["phase"]]), unique(inventories$object))) !=
            length(unique(critical_weights[[x]][["phase"]])))
          warning(paste0(
            "Not all the phases in the ", x,  " critical weights file are present in the inventories. Please check the files if it is ok.")
          )

      }
    )



  # Manipulating critical weights

    critical_weights <-
      purrr::map(
        names(critical_weights),
        \(x){
          if(x == "coke"){

            dplyr::rename(critical_weights[[x]], "weight" = "value")

          } else if (x == "silicon"){

            dplyr::rename(critical_weights[[x]], "quantity" = "value")

          }
        }
      ) |> stats::setNames(names(critical_weights))


    # Adding silicon data (to be added to exiting one)

    col_to_add_v <- # columns to add to the critical_weights$silicon tibble to perform bind_rows with inventories
      setdiff(colnames(inventories), colnames(critical_weights$silicon))

    col_to_add_v <-
      inventories |>
      dplyr::filter(comm == "silicon") |>
      dplyr::select(col_to_add_v) |>
      unique() |>
      dplyr::mutate(no_comm = as.character(.data[["no_comm"]])) |>
      tidyr::pivot_longer(dplyr::everything(), names_to = "var_names", values_to = "var_values") |>
      tibble::deframe()

    new_data_silicon <- # creating the tibble with the new silicon data
      critical_weights$silicon |>
      dplyr::mutate(!!!col_to_add_v) |>
      dplyr::mutate(no_comm = as.numeric(.data[["no_comm"]]),
                    comm = ifelse(comm == "silicon mg", "silicon"))

    inventories <- # row binding the new silicon data to inventories and adding values to exisiting ones
      inventories |>
      dplyr::bind_rows(new_data_silicon) |> # adding silicon (only has to be added to inventory data)
      dplyr::group_by(.data[["object"]], .data[["comm"]], .data[["phase"]], .data[["comp"]], .data[["um"]],
                      .data[["no_comm"]], .data[["um_to"]]) |>
      dplyr::summarise(quantity = sum(quantity), .groups = "drop") |>
      dplyr::left_join(critical_weights$coke) # adding coke critical weights


    inventories$weight <- ifelse(is.na(inventories$weight), 1, inventories$weight) # if weight is NA, set it to 1


}


} else {

  inventories$weight <- 1 # if not using weights, set weight to 1

}


  return(inventories)

}


